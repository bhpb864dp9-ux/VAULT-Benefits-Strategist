import type { TimelineEvent } from '../types';
import {
  type LegalCitation,
  type EvidenceRecord,
  getCitationsForCondition,
  getCitationsForEvidenceType,
  formatCitationsBlock,
  VBA_POLICY,
  CFR_REGULATIONS
} from './legalCitations';

export function safeFilenamePart(input: string): string {
  const trimmed = (input || '').trim();
  if (!trimmed) return 'Veteran';
  // Allow letters/numbers/underscore/dot/dash; convert everything else to underscore.
  return trimmed.replace(/[^\w.-]+/g, '_');
}

export interface BuddyStatementArgs {
  veteranName: string;
  witnessName: string;
  witnessRelationship: string;
  conditions: string[];
  observations: string;
  date?: Date;
  /** Evidence records supporting this statement */
  evidenceRecords?: EvidenceRecord[];
  /** Include legal citations in the document */
  includeCitations?: boolean;
}

export function buildBuddyStatementText(args: BuddyStatementArgs): string {
  const veteran = args.veteranName?.trim() || 'Veteran';
  const witness = args.witnessName?.trim() || 'Witness';
  const relation = args.witnessRelationship?.trim() || 'Relationship';
  const date = (args.date ?? new Date()).toLocaleDateString();
  const conditionLines = (args.conditions || []).length
    ? (args.conditions || []).map((c) => `- ${c}`).join('\n')
    : '- (not specified)';

  const obs =
    args.observations?.trim() ||
    '[Describe what you have observed: onset, frequency, severity, functional impact, changes over time, missed work, sleep issues, mood changes, mobility limitations, etc.]';

  // Gather citations
  const citations: LegalCitation[] = [];
  const seen = new Set<string>();
  
  // Always include lay evidence policy
  const layEvidence = VBA_POLICY.find(c => c.id === 'M21-1-III.iv.3.A');
  if (layEvidence) {
    citations.push(layEvidence);
    seen.add(layEvidence.id);
  }

  // Add condition-specific citations
  if (args.includeCitations !== false) {
    (args.conditions || []).forEach(condition => {
      getCitationsForCondition(condition).forEach(c => {
        if (!seen.has(c.id)) {
          seen.add(c.id);
          citations.push(c);
        }
      });
    });

    // Add evidence record citations
    (args.evidenceRecords || []).forEach(record => {
      getCitationsForEvidenceType(record.type).forEach(c => {
        if (!seen.has(c.id)) {
          seen.add(c.id);
          citations.push(c);
        }
      });
    });
  }

  // Build evidence provenance section if records exist
  let evidenceSection = '';
  if (args.evidenceRecords && args.evidenceRecords.length > 0) {
    evidenceSection = '\n\nSUPPORTING EVIDENCE RECORDS\n' + '─'.repeat(50) + '\n';
    args.evidenceRecords.forEach((record, idx) => {
      const typeLabel = record.type.replace(/_/g, ' ').toUpperCase();
      evidenceSection += `${idx + 1}. [${typeLabel}] ${record.fileName}\n`;
      evidenceSection += `   Uploaded: ${new Date(record.uploadedAt).toLocaleDateString()}\n`;
      if (record.linkedConditions.length > 0) {
        evidenceSection += `   Linked Conditions: ${record.linkedConditions.join(', ')}\n`;
      }
      evidenceSection += '\n';
    });
  }

  // Build citation block
  const citationBlock = args.includeCitations !== false && citations.length > 0
    ? formatCitationsBlock(citations)
    : '';

  return `BUDDY / LAY STATEMENT

Date: ${date}

Veteran: ${veteran}
Witness: ${witness}
Relationship: ${relation}

Conditions Observed:
${conditionLines}

Statement:
${obs}
${evidenceSection}
I declare that the statements above are true and correct to the best of my knowledge and belief.

Signature: ___________________________
Printed Name: ${witness}
${citationBlock}
─────────────────────────────────────────────────────
Generated by VAULT DEM Engine
Privacy Notice: This document was generated offline on your device.
`;
}

export interface TimelineArgs {
  veteranName: string;
  generatedAt?: Date;
  events: TimelineEvent[];
  conditions?: string[];
  evidenceRecords?: EvidenceRecord[];
  includeCitations?: boolean;
}

export function buildTimelineText(args: TimelineArgs): string {
  const veteran = args.veteranName?.trim() || 'Veteran';
  const generatedAt = (args.generatedAt ?? new Date()).toLocaleString();
  const sorted = [...(args.events || [])].sort((a, b) => (a.date || '').localeCompare(b.date || ''));

  const lines =
    sorted.length > 0
      ? sorted
          .map((e, i) => {
            const d = e.date ? e.date : 'Unknown date';
            const type = e.type.toUpperCase();
            const notes = e.notes ? `\n   Notes: ${e.notes}` : '';
            return `${i + 1}. [${type}] ${d} — ${e.title}${notes}`;
          })
          .join('\n')
      : '(no events added yet)';

  // Gather citations
  const citations: LegalCitation[] = [];
  const seen = new Set<string>();

  // Core service connection citation
  const serviceConn = CFR_REGULATIONS.find(c => c.id === 'CFR-3.303');
  if (serviceConn) {
    citations.push(serviceConn);
    seen.add(serviceConn.id);
  }

  if (args.includeCitations !== false) {
    // Add condition-specific citations
    (args.conditions || []).forEach(condition => {
      getCitationsForCondition(condition).forEach(c => {
        if (!seen.has(c.id)) {
          seen.add(c.id);
          citations.push(c);
        }
      });
    });

    // Add evidence record citations
    (args.evidenceRecords || []).forEach(record => {
      getCitationsForEvidenceType(record.type).forEach(c => {
        if (!seen.has(c.id)) {
          seen.add(c.id);
          citations.push(c);
        }
      });
    });
  }

  // Build evidence provenance section if records exist
  let evidenceSection = '';
  if (args.evidenceRecords && args.evidenceRecords.length > 0) {
    evidenceSection = '\n\nSUPPORTING EVIDENCE RECORDS\n' + '─'.repeat(50) + '\n';
    args.evidenceRecords.forEach((record, idx) => {
      const typeLabel = record.type.replace(/_/g, ' ').toUpperCase();
      evidenceSection += `${idx + 1}. [${typeLabel}] ${record.fileName}\n`;
      evidenceSection += `   Uploaded: ${new Date(record.uploadedAt).toLocaleDateString()}\n`;
      if (record.extractedData) {
        if (record.extractedData.dates.length > 0) {
          evidenceSection += `   Dates Found: ${record.extractedData.dates.slice(0, 3).join(', ')}\n`;
        }
        if (record.extractedData.diagnoses.length > 0) {
          evidenceSection += `   Diagnoses: ${record.extractedData.diagnoses.slice(0, 2).join('; ')}\n`;
        }
      }
      if (record.linkedConditions.length > 0) {
        evidenceSection += `   Linked Conditions: ${record.linkedConditions.join(', ')}\n`;
      }
      evidenceSection += '\n';
    });
  }

  // Build citation block
  const citationBlock = args.includeCitations !== false && citations.length > 0
    ? formatCitationsBlock(citations)
    : '';

  return `SERVICE TIMELINE (VAULT)

Veteran: ${veteran}
Generated: ${generatedAt}

PURPOSE: This timeline establishes the chronological chain of events from 
in-service injury/illness → onset of symptoms → medical treatment → current severity.
This supports service connection per 38 CFR § 3.303.

TIMELINE OF EVENTS
─────────────────────────────────────────────────────
${lines}
${evidenceSection}${citationBlock}
─────────────────────────────────────────────────────
Generated by VAULT DEM Engine
Privacy Notice: This document was generated offline on your device.
`;
}


