/**
 * VDIO Narrative Engine — PDF Package Generator
 * Phase 5: Compile final claim package using pdf-lib.
 *
 * Package Contents:
 * 1. Executive Summary (1 page)
 * 2. Cited Narrative (Phase 4 output)
 * 3. Evidence Index (Phase 2 OCR data table)
 * 4. Generated Forms (21-4138, 21-10210 if applicable)
 * 5. C&P Exam Pre-Brief
 *
 * @vault-feature VDIO-PDF-001 PDF Package Generation
 */
import { PDFDocument, StandardFonts, rgb, type PDFPage, type PDFFont } from 'pdf-lib';
import type { OCRIndexEntry, NarrativeBlock, GapResult, RedTeamFlag, LayEvidenceEntry, ProbabilityResult, ExamPreBrief } from '../stores/narrativeStore';

// ═══════════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════════

export interface ClaimPackageData {
  // Veteran Info
  veteranName: string;
  claimType: 'new' | 'increase' | 'secondary' | 'appeal' | 'supplemental';
  
  // Phase 2: Evidence
  ocrIndex: OCRIndexEntry[];
  documentsIngested: { id: string; name: string; type: string; processedAt: string }[];
  
  // Phase 3: Assessment
  gapAnalysis: GapResult[];
  redTeamFlags: RedTeamFlag[];
  layEvidence: LayEvidenceEntry[];
  
  // Phase 4: Narrative
  narrativeBlocks: NarrativeBlock[];
  narrativeDraft: string;
  qualityIssues: string[];
  
  // Phase 5: Output
  probabilityResult: ProbabilityResult;
  examPreBriefs: ExamPreBrief[];
}

// ═══════════════════════════════════════════════════════════════════
// CONSTANTS
// ═══════════════════════════════════════════════════════════════════

const PAGE_WIDTH = 612;  // Letter size
const PAGE_HEIGHT = 792;
const MARGIN = 50;
const LINE_HEIGHT = 14;
const HEADER_SIZE = 16;
const SUBHEADER_SIZE = 12;
const BODY_SIZE = 10;
const SMALL_SIZE = 8;

const COLORS = {
  black: rgb(0.1, 0.1, 0.1),
  gray: rgb(0.4, 0.4, 0.4),
  lightGray: rgb(0.7, 0.7, 0.7),
  brass: rgb(0.71, 0.62, 0.41),
  green: rgb(0.2, 0.6, 0.3),
  red: rgb(0.8, 0.2, 0.2),
  amber: rgb(0.8, 0.6, 0.2),
};

// ═══════════════════════════════════════════════════════════════════
// PDF HELPER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════

interface TextDrawOptions {
  x?: number;
  y: number;
  size?: number;
  font?: PDFFont;
  color?: ReturnType<typeof rgb>;
  maxWidth?: number;
}

function drawText(
  page: PDFPage,
  text: string,
  options: TextDrawOptions,
  font: PDFFont
): number {
  const {
    x = MARGIN,
    y,
    size = BODY_SIZE,
    color = COLORS.black,
    maxWidth = PAGE_WIDTH - (2 * MARGIN),
  } = options;
  
  // Simple word wrap
  const words = text.split(' ');
  const lines: string[] = [];
  let currentLine = '';
  
  for (const word of words) {
    const testLine = currentLine ? `${currentLine} ${word}` : word;
    const testWidth = font.widthOfTextAtSize(testLine, size);
    
    if (testWidth > maxWidth && currentLine) {
      lines.push(currentLine);
      currentLine = word;
    } else {
      currentLine = testLine;
    }
  }
  if (currentLine) {
    lines.push(currentLine);
  }
  
  let currentY = y;
  for (const line of lines) {
    page.drawText(line, {
      x,
      y: currentY,
      size,
      font,
      color,
    });
    currentY -= LINE_HEIGHT;
  }
  
  return currentY;
}

function drawHorizontalLine(page: PDFPage, y: number): void {
  page.drawLine({
    start: { x: MARGIN, y },
    end: { x: PAGE_WIDTH - MARGIN, y },
    thickness: 0.5,
    color: COLORS.lightGray,
  });
}

function addNewPageIfNeeded(
  doc: PDFDocument,
  currentPage: PDFPage,
  currentY: number,
  minSpace: number = 100
): { page: PDFPage; y: number } {
  if (currentY < MARGIN + minSpace) {
    const newPage = doc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
    return { page: newPage, y: PAGE_HEIGHT - MARGIN };
  }
  return { page: currentPage, y: currentY };
}

// ═══════════════════════════════════════════════════════════════════
// SECTION GENERATORS
// ═══════════════════════════════════════════════════════════════════

async function addCoverPage(
  doc: PDFDocument,
  data: ClaimPackageData,
  fonts: { regular: PDFFont; bold: PDFFont }
): Promise<void> {
  const page = doc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
  
  let y = PAGE_HEIGHT - 100;
  
  // Title
  page.drawText('VA DISABILITY CLAIM PACKAGE', {
    x: MARGIN,
    y,
    size: 24,
    font: fonts.bold,
    color: COLORS.black,
  });
  
  y -= 40;
  page.drawText('Generated by VAULT DEM Engine', {
    x: MARGIN,
    y,
    size: 12,
    font: fonts.regular,
    color: COLORS.gray,
  });
  
  y -= 60;
  drawHorizontalLine(page, y);
  y -= 30;
  
  // Veteran Info
  page.drawText('VETERAN INFORMATION', {
    x: MARGIN,
    y,
    size: HEADER_SIZE,
    font: fonts.bold,
    color: COLORS.brass,
  });
  
  y -= 30;
  page.drawText(`Name: ${data.veteranName}`, { x: MARGIN, y, size: BODY_SIZE, font: fonts.regular });
  y -= LINE_HEIGHT;
  page.drawText(`Claim Type: ${data.claimType.toUpperCase()}`, { x: MARGIN, y, size: BODY_SIZE, font: fonts.regular });
  y -= LINE_HEIGHT;
  page.drawText(`Date Generated: ${new Date().toLocaleDateString()}`, { x: MARGIN, y, size: BODY_SIZE, font: fonts.regular });
  y -= LINE_HEIGHT;
  page.drawText(`Conditions: ${data.narrativeBlocks.length}`, { x: MARGIN, y, size: BODY_SIZE, font: fonts.regular });
  
  y -= 50;
  drawHorizontalLine(page, y);
  y -= 30;
  
  // Probability Summary
  page.drawText('APPROVAL PROBABILITY ASSESSMENT', {
    x: MARGIN,
    y,
    size: HEADER_SIZE,
    font: fonts.bold,
    color: COLORS.brass,
  });
  
  y -= 30;
  const probColor = data.probabilityResult.rating === 'High' ? COLORS.green :
                    data.probabilityResult.rating === 'Medium' ? COLORS.amber : COLORS.red;
  
  page.drawText(`Overall Score: ${data.probabilityResult.overall}% (${data.probabilityResult.rating})`, {
    x: MARGIN,
    y,
    size: 14,
    font: fonts.bold,
    color: probColor,
  });
  
  y -= 30;
  y = drawText(page, data.probabilityResult.explanation, { y, size: BODY_SIZE, color: COLORS.gray }, fonts.regular);
  
  y -= 50;
  drawHorizontalLine(page, y);
  y -= 30;
  
  // Package Contents
  page.drawText('PACKAGE CONTENTS', {
    x: MARGIN,
    y,
    size: HEADER_SIZE,
    font: fonts.bold,
    color: COLORS.brass,
  });
  
  y -= 25;
  const contents = [
    '1. Executive Summary (this page)',
    '2. Cited Narrative Arguments',
    '3. Evidence Index',
    `4. Lay Evidence Statements (${data.layEvidence.length})`,
    `5. C&P Exam Pre-Briefs (${data.examPreBriefs.length})`,
    '6. Legal Citations Reference',
  ];
  
  for (const item of contents) {
    page.drawText(item, { x: MARGIN + 10, y, size: BODY_SIZE, font: fonts.regular });
    y -= LINE_HEIGHT;
  }
  
  // Footer
  page.drawText('CONFIDENTIAL - FOR VA CLAIM USE ONLY', {
    x: MARGIN,
    y: MARGIN,
    size: SMALL_SIZE,
    font: fonts.regular,
    color: COLORS.gray,
  });
}

async function addNarrativeSection(
  doc: PDFDocument,
  data: ClaimPackageData,
  fonts: { regular: PDFFont; bold: PDFFont }
): Promise<void> {
  let page = doc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
  let y = PAGE_HEIGHT - MARGIN;
  
  // Section Header
  page.drawText('CITED NARRATIVE ARGUMENTS', {
    x: MARGIN,
    y,
    size: HEADER_SIZE,
    font: fonts.bold,
    color: COLORS.brass,
  });
  y -= 30;
  
  for (const block of data.narrativeBlocks) {
    // Check if we need a new page
    ({ page, y } = addNewPageIfNeeded(doc, page, y, 150));
    
    // Condition header
    page.drawText(`CONDITION: ${block.conditionName.toUpperCase()}`, {
      x: MARGIN,
      y,
      size: SUBHEADER_SIZE,
      font: fonts.bold,
    });
    y -= 25;
    
    // Argument
    page.drawText('Argument:', { x: MARGIN, y, size: BODY_SIZE, font: fonts.bold, color: COLORS.gray });
    y -= LINE_HEIGHT;
    y = drawText(page, block.argument, { y, x: MARGIN + 10 }, fonts.regular);
    y -= 15;
    
    // Evidence
    page.drawText('Evidence:', { x: MARGIN, y, size: BODY_SIZE, font: fonts.bold, color: COLORS.gray });
    y -= LINE_HEIGHT;
    for (const citation of block.evidenceCitations) {
      ({ page, y } = addNewPageIfNeeded(doc, page, y, 50));
      y = drawText(page, `• ${citation}`, { y, x: MARGIN + 10 }, fonts.regular);
      y -= 5;
    }
    y -= 10;
    
    // Law
    page.drawText('Legal Authority:', { x: MARGIN, y, size: BODY_SIZE, font: fonts.bold, color: COLORS.gray });
    y -= LINE_HEIGHT;
    for (const law of block.lawCitations) {
      ({ page, y } = addNewPageIfNeeded(doc, page, y, 50));
      y = drawText(page, `• ${law}`, { y, x: MARGIN + 10 }, fonts.regular);
      y -= 5;
    }
    
    y -= 20;
    drawHorizontalLine(page, y);
    y -= 20;
  }
}

async function addEvidenceIndex(
  doc: PDFDocument,
  data: ClaimPackageData,
  fonts: { regular: PDFFont; bold: PDFFont }
): Promise<void> {
  let page = doc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
  let y = PAGE_HEIGHT - MARGIN;
  
  page.drawText('EVIDENCE INDEX', {
    x: MARGIN,
    y,
    size: HEADER_SIZE,
    font: fonts.bold,
    color: COLORS.brass,
  });
  y -= 30;
  
  page.drawText(`Total Indexed Entries: ${data.ocrIndex.length}`, {
    x: MARGIN,
    y,
    size: BODY_SIZE,
    font: fonts.regular,
    color: COLORS.gray,
  });
  y -= 20;
  
  // Table header
  page.drawText('Source', { x: MARGIN, y, size: SMALL_SIZE, font: fonts.bold });
  page.drawText('Page', { x: MARGIN + 150, y, size: SMALL_SIZE, font: fonts.bold });
  page.drawText('Date', { x: MARGIN + 190, y, size: SMALL_SIZE, font: fonts.bold });
  page.drawText('Condition', { x: MARGIN + 270, y, size: SMALL_SIZE, font: fonts.bold });
  page.drawText('Law', { x: MARGIN + 370, y, size: SMALL_SIZE, font: fonts.bold });
  y -= 10;
  drawHorizontalLine(page, y);
  y -= 15;
  
  for (const entry of data.ocrIndex.slice(0, 50)) { // Limit to 50 for PDF size
    ({ page, y } = addNewPageIfNeeded(doc, page, y, 30));
    
    const truncSource = entry.source.length > 20 ? entry.source.slice(0, 17) + '...' : entry.source;
    const truncCondition = entry.taggedCondition.length > 15 ? entry.taggedCondition.slice(0, 12) + '...' : entry.taggedCondition;
    
    page.drawText(truncSource, { x: MARGIN, y, size: SMALL_SIZE, font: fonts.regular });
    page.drawText(entry.page, { x: MARGIN + 150, y, size: SMALL_SIZE, font: fonts.regular });
    page.drawText(entry.date || '—', { x: MARGIN + 190, y, size: SMALL_SIZE, font: fonts.regular });
    page.drawText(truncCondition || '—', { x: MARGIN + 270, y, size: SMALL_SIZE, font: fonts.regular });
    page.drawText(entry.relevantLaw || '—', { x: MARGIN + 370, y, size: SMALL_SIZE, font: fonts.regular });
    
    y -= LINE_HEIGHT;
  }
  
  if (data.ocrIndex.length > 50) {
    y -= 10;
    page.drawText(`... and ${data.ocrIndex.length - 50} more entries (see full export)`, {
      x: MARGIN,
      y,
      size: SMALL_SIZE,
      font: fonts.regular,
      color: COLORS.gray,
    });
  }
}

async function addLayEvidenceSection(
  doc: PDFDocument,
  data: ClaimPackageData,
  fonts: { regular: PDFFont; bold: PDFFont }
): Promise<void> {
  if (data.layEvidence.length === 0) return;
  
  let page = doc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
  let y = PAGE_HEIGHT - MARGIN;
  
  page.drawText('LAY EVIDENCE STATEMENTS', {
    x: MARGIN,
    y,
    size: HEADER_SIZE,
    font: fonts.bold,
    color: COLORS.brass,
  });
  y -= 30;
  
  for (const lay of data.layEvidence) {
    ({ page, y } = addNewPageIfNeeded(doc, page, y, 200));
    
    page.drawText(`Witness: ${lay.witnessName} (${lay.witnessRelation})`, {
      x: MARGIN,
      y,
      size: SUBHEADER_SIZE,
      font: fonts.bold,
    });
    y -= 20;
    
    // Draw the statement
    const lines = lay.statement.split('\n');
    for (const line of lines.slice(0, 30)) { // Limit lines
      ({ page, y } = addNewPageIfNeeded(doc, page, y, 30));
      y = drawText(page, line, { y, size: SMALL_SIZE }, fonts.regular);
    }
    
    y -= 20;
    drawHorizontalLine(page, y);
    y -= 20;
  }
}

async function addExamPreBriefSection(
  doc: PDFDocument,
  data: ClaimPackageData,
  fonts: { regular: PDFFont; bold: PDFFont }
): Promise<void> {
  if (data.examPreBriefs.length === 0) return;
  
  let page = doc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
  let y = PAGE_HEIGHT - MARGIN;
  
  page.drawText('C&P EXAM PREPARATION SHEETS', {
    x: MARGIN,
    y,
    size: HEADER_SIZE,
    font: fonts.bold,
    color: COLORS.brass,
  });
  y -= 30;
  
  for (const brief of data.examPreBriefs) {
    ({ page, y } = addNewPageIfNeeded(doc, page, y, 250));
    
    page.drawText(`${brief.conditionName}`, {
      x: MARGIN,
      y,
      size: SUBHEADER_SIZE,
      font: fonts.bold,
    });
    y -= 15;
    page.drawText(`DBQ: ${brief.dbqForm}`, {
      x: MARGIN,
      y,
      size: SMALL_SIZE,
      font: fonts.regular,
      color: COLORS.gray,
    });
    y -= 20;
    
    // Key Questions
    page.drawText('Key Questions:', { x: MARGIN, y, size: BODY_SIZE, font: fonts.bold });
    y -= LINE_HEIGHT;
    for (const q of brief.keyQuestions.slice(0, 3)) {
      y = drawText(page, `• ${q}`, { y, x: MARGIN + 10, size: SMALL_SIZE }, fonts.regular);
    }
    y -= 10;
    
    // Tips
    page.drawText('Exam Tips:', { x: MARGIN, y, size: BODY_SIZE, font: fonts.bold });
    y -= LINE_HEIGHT;
    for (const tip of brief.tipsForVeteran.slice(0, 3)) {
      y = drawText(page, `★ ${tip}`, { y, x: MARGIN + 10, size: SMALL_SIZE }, fonts.regular);
    }
    
    y -= 20;
    drawHorizontalLine(page, y);
    y -= 20;
  }
}

// ═══════════════════════════════════════════════════════════════════
// MAIN GENERATOR
// ═══════════════════════════════════════════════════════════════════

export async function generateClaimPackage(data: ClaimPackageData): Promise<Uint8Array> {
  const doc = await PDFDocument.create();
  
  // Embed fonts
  const regularFont = await doc.embedFont(StandardFonts.Helvetica);
  const boldFont = await doc.embedFont(StandardFonts.HelveticaBold);
  const fonts = { regular: regularFont, bold: boldFont };
  
  // Set document metadata
  doc.setTitle(`VA Claim Package - ${data.veteranName}`);
  doc.setSubject('VA Disability Claim Documentation');
  doc.setCreator('VAULT DEM Engine');
  doc.setCreationDate(new Date());
  
  // Add sections
  await addCoverPage(doc, data, fonts);
  await addNarrativeSection(doc, data, fonts);
  await addEvidenceIndex(doc, data, fonts);
  await addLayEvidenceSection(doc, data, fonts);
  await addExamPreBriefSection(doc, data, fonts);
  
  // Serialize to bytes
  return await doc.save();
}

/**
 * Generate and trigger download
 */
export async function downloadClaimPackage(data: ClaimPackageData): Promise<void> {
  const pdfBytes = await generateClaimPackage(data);
  
  const blob = new Blob([new Uint8Array(pdfBytes)], { type: 'application/pdf' });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = `VAULT_Claim_Package_${data.veteranName.replace(/\s/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  URL.revokeObjectURL(url);
}

/**
 * Get estimated page count
 */
export function estimatePageCount(data: ClaimPackageData): number {
  let pages = 1; // Cover page
  pages += Math.ceil(data.narrativeBlocks.length / 2); // Narrative
  pages += Math.ceil(data.ocrIndex.length / 30); // Evidence index
  pages += data.layEvidence.length; // Lay statements
  pages += Math.ceil(data.examPreBriefs.length / 2); // Pre-briefs
  return pages;
}

export default {
  generateClaimPackage,
  downloadClaimPackage,
  estimatePageCount,
};

